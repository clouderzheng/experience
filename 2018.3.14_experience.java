使用json打印java对象的坑
com.alibaba.fastjson.JSON.toJSONString(obj)
当obj对象为java对象的时候，此时obj对象中没有getter方法，此方法将只能打印公共参数，不能打印保护，私有参数



http://blog.csdn.net/wabiaozia/article/details/78631259  schema


对象的引用 包括：
1、句柄的引用，java栈中包含java堆中句柄的地址，每个句柄包含实例数据地址和类型数据地址，修改比较方便，gc过后只要修改实例数据的地址，reference指向不变
2、直接指针引用，java栈指向java中的实例数据地址，少了一次指向，访问速度快

多线程情况下，内存溢出，怎么保存多线程。

操作系统分配给每个进程的内存是有限制的，譬如 32 位的 Windows 限制为 2GB。虚拟机提供了参数来控制 Java 堆和方法区的这两部分内存的最大值。剩余的内存为 2GB（操作系统限制）减去 Xmx（最大堆容量），再减去 MaxPermSize（最大方法区容量），程序计数器消耗内存很小，可以忽略掉。如果虚拟机进程本身耗费的内存不计算在内，剩下的内存就由虚拟机栈和本地方法栈“瓜分”了。每个线程分配到的栈容量越大，可以建立的线程数量自然就越少，建立线程时就越容易把剩下的内存耗尽。

更简单理解的就是：有一个操作系统为2G，我们分配给两个线程，每个800M，也就还剩400M，这样的话，有一个线程不够用的话，就会在400里边申请，所以如果剩下的越多，出现OOM的可能性越小，如果每个分配950M，这样就剩100M，这样的话出现OOM的可能性就更大。如果在增加线程，系统对每一个线程非配的内存是一定的，所以剩下的内存更少，这样的话，出现OOM的可能更大，但这都是相对而说。

遇到OOM这时候我们应该怎么做：

如果是建立过多线程导致的内存溢出，在不能减少线程数或者更换 64 位虚拟机的情况下，就只能通过减少最大堆和减少栈容量来换取更多的线程。如果没有这方面的经验，这种通过“减少内存”的手段来解决内存溢出的方式会比较难以想到。这种拆东墙补西墙的方法，还是自己意会吧。


线程池的线程执行规则跟任务队列有很大的关系。

下面都假设任务队列没有大小限制：

如果线程数量<=核心线程数量，那么直接启动一个核心线程来执行任务，不会放入队列中。
如果线程数量>核心线程数，但<=最大线程数，并且任务队列是LinkedBlockingDeque的时候，超过核心线程数量的任务会放在任务队列中排队。
如果线程数量>核心线程数，但<=最大线程数，并且任务队列是SynchronousQueue的时候，线程池会创建新线程执行任务，这些任务也不会被放在任务队列中。这些线程属于非核心线程，在任务完成后，闲置时间达到了超时时间就会被清除。
如果线程数量>核心线程数，并且>最大线程数，当任务队列是LinkedBlockingDeque，会将超过核心线程的任务放在任务队列中排队。也就是当任务队列是LinkedBlockingDeque并且没有大小限制时，线程池的最大线程数设置是无效的，他的线程数最多不会超过核心线程数。
如果线程数量>核心线程数，并且>最大线程数，当任务队列是SynchronousQueue的时候，会因为线程池拒绝添加任务而抛出异常。
任务队列大小有限时

当LinkedBlockingDeque塞满时，新增的任务会直接创建新线程来执行，当创建的线程数量超过最大线程数量时会抛异常。
SynchronousQueue没有数量限制。因为他根本不保持这些任务，而是直接交给线程池去执行。当任务数量超过最大线程数时会直接抛异常。